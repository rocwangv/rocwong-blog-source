---
title: 位操作符与移位运算
date: 2018-06-11 14:50:52
tags:
- 位移运算
categories:
- 学习笔记
---
位操作符用于在最近本的层次上，即按内存中表示数值的位来操作数值。
ECMAScript中的所有数值都以 IEEE-754 64 位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。

<!-- more -->

对于我们来说， 由于64位存储格式是透明的，因此整个过程就像是只存在32位的整数一样。

对于有符号的整数，32位中的前31位用于表示整数的值。第32位用于表示数值的符号：0表示正数，1表示负数。这个表示符号的位叫做**符号位**，符号位的值决定了其他位数值的格式。其中，正数以纯二进制格式存储，31位中的每一位都表示2的幂。第一位（叫做位0）表示2的0次幂，第二位表示2的1次幂，以此类推。
没有用到的位以0填充，即忽略不计。例如，数值18的二进制表示是`00000000000000000000000000010010`，或者更简洁的`10010`。这个5个有效位，这5位本身就决定了实际的值。

负数同样以二进制码存储，但是用的格式是**二进制补码**。计算一个数值的二进制补码，需要经过下面3个步骤：

* 求这个数值绝对值的二进制码（例如，要求-18的二进制补码，先求18的二进制码）；
* 求二进制反码，即将0替换为1，将1替换为0；
* 得到的二进制反码加1。
要根据这个3个步骤求得-18的二进制码，首先就要求得18的二进制码，即：

```text
0000 0000 0000 0000 0000 0000 0001 0010
```
然后，求其二进制反码，即0和1互换：

```text
1111 1111 1111 1111 1111 1111 1110 1101
```
最后，二进制反码加1：

```text
1111 1111 1111 1111 1111 1111 1110 1101
                                      1
---------------------------------------
1111 1111 1111 1111 1111 1111 1110 1110
```
这样，就求得了-18的二进制表示，即`11111111111111111111111111101110`。需要注意的是，在处理有符号整数时，是不能访问位31的。

在ECMAScript中，当对数值应用位操作符时，后台会发生如下转换过程：64位的数值被转换成32位数值，然后执行位操作，最后再将32位的结果转换回64位数值。这样，表面上看起来就好像是在操作32位数值，就跟着其他语言中以类似的方式执行二进制操作一样。但这个转换过程也导致了一个严重的负效应，即在对特殊的`NaN`和`Infinity`值应用位操作时，这两个值都会被当做0来处理。
如果对非数值应用位操作符，会先使用`Number()`函数将该值转换为一个数值（自动完成），然后在应用位操作，得到的结果将是一个数值。

## 1.按位非（NOT)
按位非操作符由一个波浪线（~）表示，执行按位非的结果就是返回数值的反码。按位非是ECMAScript操作符中少数几个与二进制计算有关的操作符之一。如：

```js
var num1 = 25;               //二进制 00000000000000000000000000011001
var num2 = ~num1;            //二进制 11111111111111111111111111100110
alert(num2);                 // -26
```
这里，对25执行按位非操作，结果得到了-26。这也验证了按位非操作的本质：**操作数的负值减一**。但是由于按位非是在数值表示的最底层执行操作，因此速度更快。

## 2.按位与（AND)
按位与操作符是由一个和号字符（&）表示，它有两个操作符数。从本质上将，按位与操作就是将两个数值的每一位对其，然后根据下表中的规则，对相同位置上的两个数执行AND操作：

| 第一个数值的位 | 第二个数值的位 | 结果
| ------------ |:------------|:-------
| 1            | 1           | 1
| 1            | 0           | 0
| 0            | 1           | 0
| 0            | 0           | 0

简而言之，按位与操作旨在两个数值的对应位都是1时才返回1，任何一位是0，结果都是0。
下面看一个对25和3执行按位与操作的例子：

```js
var result = 25 & 3;
alert(result);            // 1
```
其底层操作：

```text
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
----------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001
```
## 3.按位或 （OR)
按位或操作符由一个竖线符号（|）表示，同样也有两个操作数。按位或操作遵循下面这个真值表：

| 第一个数值的位 | 第二个数值的位 | 结果
| ------------ |:------------|:-------
| 1            | 1           | 1
| 1            | 0           | 1
| 0            | 1           | 1
| 0            | 0           | 0

由此可见，按位或操作在有一个位是1的情况下就返回1，而只有在两个位都是0的情况下才返回0。
如果在前面按位与的例子中对25和3进行按位或操作，则代码如下：

```js
var result = 25 | 3;
alert(result);         // 27
```
25与3按位或的结果是27：

```text
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
----------------------------------------------
 OR = 0000 0000 0000 0000 0000 0000 0001 1011
```
## 4.按位异或 （XOR)
按位异或操作符由一个插入符号（^）表示，也有两个操作数，以下是按位异或的真值表：

| 第一个数值的位 | 第二个数值的位 | 结果
| ------------ |:------------|:-------
| 1            | 1           | 0
| 1            | 0           | 1
| 0            | 1           | 1
| 0            | 0           | 0

按位异或与按位或的不同之处在于，这个操作在**两个数值对应为上只有一个1时才返回1，如果对应的两位都是1或都是0，则返回0**.
对25和3执行按位异或操作的代码如下：

```js
var result = 25 ^ 3;
alert(result);         // 26
```
其底层代码如下：

```text
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
----------------------------------------------
 OR = 0000 0000 0000 0000 0000 0000 0001 1010
```
## 5.左移 
左移操作符由两个小于号（<<）表示，这个操作符会将数值的所有位向左移动指定的位数。如：

```js
var oldVal = 2;                   //二进制 10
var newVal = oldVal << 5;         //二进制1000000，十进制64
alert(newVal);                    // 64
```
注意，在想做移位后，原数值的右侧多出了5个空位，左移操作会以0来填充这些空位，以便得到的结果是一个完整的42位二进制数。而且左移不会影响操作数的符号位，换句话说，如果将-2向左移动5位，结果将是-64，而非64。

## 6.有符号的右移
有符号的右移操作由两个大于号（>>）表示，这个操作符将会将数值向右移动，但保留符号位（即正负号标记）。有符号的右移操作与左移操作恰好相反，即如果将64向右移动5位，结果将便会2。

```js
var oldVal = 64;                   //二进制1000000
var newVal = oldVal >> 5;         //二进制10
alert(newVal);                    // 2
```
## 7.无符号右移
无符号右移操作符由3个大于号（>>>）表示，这个操作符会将数值的所有32位都向右移动，对正数来说，无符号右移的结果与右移相同。扔以前面有符号的代码为例，如果将64无符号右移5位，结果仍然还是2：

```js
var oldVal = 64;                   //二进制1000000
var newVal = oldVal >>> 5;         //二进制10
alert(newVal);                    // 2
```
但是对于负数来说就不一样了。首先，无符号右移是以0来填充空位，而不是像有符号右移那样以符号位的值来填充空位。所以，对证书的无符号右移与有符号右移结果相同，但是对负数的结果就不同了。其次，无符号有意操作符会把负数的二进制码当做正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因为就会导致无符号右移后的结果非常之大。

```js
var oldVal = -64;                  // 等于二进制的11111111111111111111111111000000
var newVal = oldVal >>> 5;         // 等于十进制的134217726
```
